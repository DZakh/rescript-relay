let fs = require("fs");
let path = require("path");
let { printRE, parseRE } = require("reason");

function generateSchemaAssets(schema, targetPath) {
  let enums = schema.data.__schema.types
    .filter(({ kind, name }) => kind === "ENUM" && !name.startsWith("_"))
    .map(e => {
      const { name, enumValues } = e;
      const values = enumValues.map(v => v.name);

      const hasFutureAddedValueStr = !!values.find(
        v => v === "FutureAddedValue"
      );

      const futureAddedValueName = `FutureAddedValue${
        hasFutureAddedValueStr ? "_" : ""
      }`;

      let enumT = `type t = [ ${values
        .map(v => ` | \`${v}`)
        .join("")} | \`${futureAddedValueName}(string) ]`;

      return `
      module Enum_${name}: {
        ${enumT};
        type wrapped;
        let unwrap: wrapped => t;
        let wrap: t => wrapped;
        let toString: t => string;
        let fromString: string => t;
      } = {
        ${enumT};
        type wrapped;
        
        external __unwrap: wrapped => string = "%identity";
        external __wrap: string => wrapped = "%identity";
        
        let unwrap = wrapped => switch(wrapped |> __unwrap) {
          ${values.map(val => `| "${val}" => \`${val}`).join("")}
          | v => \`${futureAddedValueName}(v)
        };
        
        let wrap = t => switch(t) {
          ${values.map(val => `| \`${val} => "${val}"`).join("")}
          | \`${futureAddedValueName}(_) => ""
        } |> __wrap;

        let toString = t => t |> wrap |> __unwrap;
        let fromString = str => str |> __wrap |> unwrap;
      };
      `;
    })
    .join("\n\n");

  fs.writeFileSync(
    path.resolve(targetPath + "/SchemaAssets.re"),
    printRE(
      parseRE(`
/** This file is autogenerated by ReasonRelay and should not be modified manually. */

/**
 * ENUMS
 * Helpers for wrapping/unwrapping enums.
 */

${enums}
     `)
    )
  );
}

module.exports = {
  generateSchemaAssets
};
