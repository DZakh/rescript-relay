// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Language plugin tests Explicit __typename selection throws when selecting a union without an explicit __typename selection 1`] = `
[GraphQLError: Unions and interfaces must have the field __typename explicitly selected. Please add __typename to the fields selected by "participantById" in your operation.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             participantById(id: "123") {
               ^
3:               ... on User {
]
`;

exports[`Language plugin tests Field names Cannot start with uppercase letter throws when trying to use a field name starting with an uppercase 1`] = `
[GraphQLError: Found an invalid field name: Field names may not start with an uppercase letter. Please alias the 'Observer' field to something starting with a lowercase letter.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             Observer(id: "123") {
               ^
3:               id
]
`;

exports[`Language plugin tests Field names Reserved keywords throws when trying to use a field name that's a reserved keyword 1`] = `
[GraphQLError: Found an invalid field name: 'new' is a reserved keyword in ReasonML and therefore cannot be used as a field name. Please alias your field to something else.

Source: GraphQL request (3:17)
2:               user(id: "123") {
3:                 new
                   ^
4:               }
]
`;

exports[`Language plugin tests Fragment prints the correct fragment ref extractor helpers and base types 1`] = `
"// SomeComponent_user.graphql
/* @generated */

module Types = {};

type fragment = {id: string};

module FragmentConverters: {} = {};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(array((int, string))) = [%raw {| {} |}];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__SomeComponent_user\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

type operationType = ReasonRelay.fragmentNode;
"
`;

exports[`Language plugin tests Mutation prints the correct basic structure for mutations 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */

module Types = {
  type changedUser = {
    id: string,
    firstName: string,
  };
  type setUserLocation = {changedUser: option(changedUser)};
  type locationBounds = {
    lat: float,
    lng: float,
  };
  type setUserLocationInput = {
    clientMutationId: option(string),
    userId: string,
    location: option(locationBounds),
  };
};

open Types;

type response = {setUserLocation};
type variables = {input: setUserLocationInput};

module FragmentConverters: {} = {};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(array((int, string))) = [%raw
    {| {\\"setUserLocation_changedUser\\":[[0,\\"\\"]]} |}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v
    ->ReasonRelay._convertObj(
        wrapResponseConverter,
        wrapResponseConverterMap,
        Js.null,
      );

  type responseRaw;
  let responseConverter: Js.Dict.t(array((int, string))) = [%raw
    {| {\\"setUserLocation_changedUser\\":[[0,\\"\\"]]} |}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(array((int, string))) = [%raw {| {} |}];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

type operationType = ReasonRelay.mutationNode;
"
`;

exports[`Language plugin tests Query prints simple responses and variables 1`] = `
"// appQuery.graphql
/* @generated */

module Types = {
  type user = {
    id: string,
    firstName: string,
  };
};

open Types;

type response = {user: option(user)};
type refetchVariables = {userId: option(string)};
let makeRefetchVariables = (~userId=?, ()): refetchVariables => {
  userId: userId,
};
type variables = {userId: string};

module FragmentConverters: {} = {};

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(array((int, string))) = [%raw
    {| {\\"user\\":[[0,\\"\\"]]} |}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(array((int, string))) = [%raw {| {} |}];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

type operationType = ReasonRelay.queryNode;
"
`;

exports[`Language plugin tests Subscription prints the correct basic structure for subscriptions 1`] = `
"// SomeSubscription.graphql
/* @generated */

module Types = {
  type user = {
    id: string,
    firstName: string,
  };
  type userChanged = {user: option(user)};
  type userChangedInput = {
    clientMutationId: option(string),
    userId: string,
  };
};

open Types;

type response = {userChanged};
type variables = {input: userChangedInput};

module FragmentConverters: {} = {};

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(array((int, string))) = [%raw
    {| {\\"userChanged_user\\":[[0,\\"\\"]]} |}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(array((int, string))) = [%raw {| {} |}];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

type operationType = ReasonRelay.subscriptionNode;
"
`;

exports[`Language plugin tests Unions generates code to unwrap unions 1`] = `
"// appQuery.graphql
/* @generated */

module Union_response_participantById: {
  type wrapped;
  type user = {
    lastName: string,
    firstName: string,
    id: string,
  };
  type observer = {
    name: string,
    id: string,
  };
  type t = [ | \`User(user) | \`Observer(observer) | \`UnmappedUnionMember];
  let unwrap: wrapped => t;
} = {
  type wrapped;
  type user = {
    lastName: string,
    firstName: string,
    id: string,
  };
  type observer = {
    name: string,
    id: string,
  };
  external __unwrap_union: wrapped => {. \\"__typename\\": string} = \\"%identity\\";
  type t = [ | \`User(user) | \`Observer(observer) | \`UnmappedUnionMember];
  external __unwrap_user: wrapped => user = \\"%identity\\";
  external __unwrap_observer: wrapped => observer = \\"%identity\\";
  let unwrap = wrapped => {
    let unwrappedUnion = wrapped |> __unwrap_union;
    switch (unwrappedUnion##__typename) {
    | \\"User\\" => \`User(wrapped |> __unwrap_user)
    | \\"Observer\\" => \`Observer(wrapped |> __unwrap_observer)
    | _ => \`UnmappedUnionMember
    };
  };
};
module Types = {};

type response = {participantById: option(Union_response_participantById.t)};
type variables = unit;

module FragmentConverters: {} = {};

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(array((int, string))) = [%raw
    {| {\\"participantById\\":[[0,\\"\\"],[3,\\"response_participantById\\"]]} |}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": Union_response_participantById.unwrap,
  };
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(array((int, string))) = [%raw {| {} |}];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

type operationType = ReasonRelay.queryNode;
"
`;
