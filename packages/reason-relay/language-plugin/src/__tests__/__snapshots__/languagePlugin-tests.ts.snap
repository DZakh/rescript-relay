// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Language plugin tests Explicit __typename selection throws when selecting a union without an explicit __typename selection 1`] = `
[GraphQLError: Unions and interfaces must have the field __typename explicitly selected. Please add __typename to the fields selected by "participantById" in your operation.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             participantById(id: "123") {
               ^
3:               ... on User {
]
`;

exports[`Language plugin tests Field names Cannot start with uppercase letter throws when trying to use a field name starting with an uppercase 1`] = `
[GraphQLError: Found an invalid field name: Field names may not start with an uppercase letter. Please alias the 'Observer' field to something starting with a lowercase letter.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             Observer(id: "123") {
               ^
3:               id
]
`;

exports[`Language plugin tests Field names Reserved keywords throws when trying to use a field name that's a reserved keyword 1`] = `
[GraphQLError: Found an invalid field name: 'new' is a reserved keyword in ReasonML and therefore cannot be used as a field name. Please alias your field to something else.

Source: GraphQL request (3:17)
2:               user(id: "123") {
3:                 new
                   ^
4:               }
]
`;

exports[`Language plugin tests Fragment prints the correct fragment ref extractor helpers and base types 1`] = `
"// SomeComponent_user.graphql
type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__SomeComponent_user\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

type fragment = {. \\"id\\": string};
type operationType = ReasonRelay.fragmentNode;

module Unions = {};
"
`;

exports[`Language plugin tests Mutation prints the correct basic structure for mutations 1`] = `
"// SetUserLocationMutation.graphql
type response = {
  .
  \\"setUserLocation\\": {
    .
    \\"changedUser\\":
      Js.Nullable.t({
        .
        \\"firstName\\": string,
        \\"id\\": string,
      }),
  },
};
type variables = {
  .
  \\"input\\": {
    .
    \\"location\\":
      option({
        .
        \\"lng\\": float,
        \\"lat\\": float,
      }),
    \\"userId\\": string,
    \\"clientMutationId\\": option(string),
  },
};
type operationType = ReasonRelay.mutationNode;

module Unions = {};
"
`;

exports[`Language plugin tests Query prints nested objects inlined in types 1`] = `
"// appQuery.graphql
type response = {
  .
  \\"userByLocation\\":
    Js.Nullable.t({
      .
      \\"firstName\\": string,
      \\"id\\": string,
    }),
};
type refetchVariables = {
  .
  \\"location\\":
    option({
      .
      \\"lng\\": float,
      \\"lat\\": float,
    }),
};
let makeRefetchVariables = (~location=?, ()): refetchVariables => {
  \\"location\\": location,
};
type variables = {
  .
  \\"location\\": {
    .
    \\"lng\\": float,
    \\"lat\\": float,
  },
};
type operationType = ReasonRelay.queryNode;

module Unions = {};
"
`;

exports[`Language plugin tests Query prints simple responses and variables 1`] = `
"// appQuery.graphql
type response = {
  .
  \\"user\\":
    Js.Nullable.t({
      .
      \\"firstName\\": string,
      \\"id\\": string,
    }),
};
type refetchVariables = {. \\"userId\\": option(string)};
let makeRefetchVariables = (~userId=?, ()): refetchVariables => {
  \\"userId\\": userId,
};
type variables = {. \\"userId\\": string};
type operationType = ReasonRelay.queryNode;

module Unions = {};
"
`;

exports[`Language plugin tests Subscription prints the correct basic structure for subscriptions 1`] = `
"// SomeSubscription.graphql
type response = {
  .
  \\"userChanged\\": {
    .
    \\"user\\":
      Js.Nullable.t({
        .
        \\"firstName\\": string,
        \\"id\\": string,
      }),
  },
};
type variables = {
  .
  \\"input\\": {
    .
    \\"userId\\": string,
    \\"clientMutationId\\": option(string),
  },
};
type operationType = ReasonRelay.subscriptionNode;

module Unions = {};
"
`;

exports[`Language plugin tests Unions generates code to unwrap unions 1`] = `
"// appQuery.graphql
type union_response_participantById_wrapped;
type response = {
  .
  \\"participantById\\": Js.Nullable.t(union_response_participantById_wrapped),
};
type variables = unit;
type operationType = ReasonRelay.queryNode;

module Unions = {
  module Union_response_participantById: {
    type type_User = {
      .
      \\"id\\": string,
      \\"firstName\\": string,
      \\"lastName\\": string,
    };
    type type_Observer = {
      .
      \\"id\\": string,
      \\"name\\": string,
    };
    type t = [
      | \`User(type_User)
      | \`Observer(type_Observer)
      | \`UnmappedUnionMember
    ];
    let unwrap: union_response_participantById_wrapped => t;
  } = {
    external __unwrap_union:
      union_response_participantById_wrapped => {. \\"__typename\\": string} =
      \\"%identity\\";
    type type_User = {
      .
      \\"id\\": string,
      \\"firstName\\": string,
      \\"lastName\\": string,
    };
    type type_Observer = {
      .
      \\"id\\": string,
      \\"name\\": string,
    };
    type t = [
      | \`User(type_User)
      | \`Observer(type_Observer)
      | \`UnmappedUnionMember
    ];
    external __unwrap_User: union_response_participantById_wrapped => type_User =
      \\"%identity\\";
    external __unwrap_Observer:
      union_response_participantById_wrapped => type_Observer =
      \\"%identity\\";
    let unwrap = wrapped => {
      let unwrappedUnion = wrapped |> __unwrap_union;
      switch (unwrappedUnion##__typename) {
      | \\"User\\" => \`User(wrapped |> __unwrap_User)
      | \\"Observer\\" => \`Observer(wrapped |> __unwrap_Observer)
      | _ => \`UnmappedUnionMember
      };
    };
  };
};
"
`;
