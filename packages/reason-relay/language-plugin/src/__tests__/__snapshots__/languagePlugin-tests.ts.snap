// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Language plugin tests Explicit __typename selection throws when selecting a union without an explicit __typename selection 1`] = `
[GraphQLError: Unions and interfaces must have the field __typename explicitly selected. Please add __typename to the fields selected by "participantById" in your operation.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             participantById(id: "123") {
               ^
3:               ... on User {
]
`;

exports[`Language plugin tests Field names Cannot start with uppercase letter throws when trying to use a field name starting with an uppercase 1`] = `
[GraphQLError: Found an invalid field name: Field names may not start with an uppercase letter. Please alias the 'Observer' field to something starting with a lowercase letter.

Source: GraphQL request (2:13)
1: query SomeQuery {
2:             Observer(id: "123") {
               ^
3:               id
]
`;

exports[`Language plugin tests Field names Reserved keywords renames reserved keywords as field names in types when encountered 1`] = `
"// SomeMutation.graphql
/* @generated */

module Unions = {};

module Types = {
  type mutationWithReservedNameInput = {
    [@bs.as \\"or\\"]
    or_: bool,
    [@bs.as \\"and\\"]
    and_: string,
    nested: option(mutationWithReservedNameInput),
  };
};

open Types;

type response = {mutationWithReservedName: bool};
type variables = {input: mutationWithReservedNameInput};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v
    ->ReasonRelay._convertObj(
        wrapResponseConverter,
        wrapResponseConverterMap,
        Js.null,
      );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"input\\":{\\"r\\":\\"MutationWithReservedNameInput\\"}},\\"MutationWithReservedNameInput\\":{\\"nested\\":{\\"n\\":\\"\\",\\"r\\":\\"MutationWithReservedNameInput\\"}}} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {
  let make_mutationWithReservedNameInput =
      (~or_, ~and_, ~nested=?, ()): mutationWithReservedNameInput => {
    or_,
    and_,
    nested,
  };

  let makeVariables = (~input): variables => {input: input};

  let makeOptimisticResponse = (~mutationWithReservedName): response => {
    mutationWithReservedName: mutationWithReservedName,
  };
};

type operationType = ReasonRelay.mutationNode;
"
`;

exports[`Language plugin tests Field names Reserved keywords throws when trying to use a field name that's a reserved keyword 1`] = `
[GraphQLError: Found an invalid field name: 'new' is a reserved keyword in ReasonML and therefore cannot be used as a field name. Please alias your field to something else.

Source: GraphQL request (3:17)
2:               user(id: "123") {
3:                 new
                   ^
4:               }
]
`;

exports[`Language plugin tests Fragment prints indications of existing fragment refs in generated types 1`] = `
"// SomeComponent_user.graphql
/* @generated */

module Unions = {};

module Types = {};

type fragment = {id: string};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__SomeComponent_user\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {};

type operationType = ReasonRelay.fragmentNode;


// SomeOtherComponent_user.graphql
/* @generated */

module Unions = {};

module Types = {};

type fragment = {
  getFragmentRefs:
    unit =>
    {. \\"__$fragment_ref__SomeComponent_user\\": SomeComponent_user_graphql.t},
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"\\":{\\"f\\":\\"\\"}}} |}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__SomeOtherComponent_user\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {};

type operationType = ReasonRelay.fragmentNode;
"
`;

exports[`Language plugin tests Fragment prints the correct fragment ref extractor helpers and base types 1`] = `
"// SomeComponent_user.graphql
/* @generated */

module Unions = {};

module Types = {};

type fragment = {id: string};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__SomeComponent_user\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {};

type operationType = ReasonRelay.fragmentNode;
"
`;

exports[`Language plugin tests Mutation generates the correct converter for complex variables 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */

type enum_UserRole = [ | \`Admin | \`User | \`FutureAddedValue(string)];

let unwrap_enum_UserRole: string => enum_UserRole =
  fun
  | \\"Admin\\" => \`Admin
  | \\"User\\" => \`User
  | v => \`FutureAddedValue(v);

let wrap_enum_UserRole: enum_UserRole => string =
  fun
  | \`Admin => \\"Admin\\"
  | \`User => \\"User\\"
  | \`FutureAddedValue(v) => v;

module Unions = {};

module Types = {
  type locationBounds = {
    lat: float,
    lng: float,
    child: option(locationBounds),
  };
  type setUserLocationInput = {
    clientMutationId: option(string),
    userId: string,
    location: option(locationBounds),
  };
  type response_setUserLocation_changedUser = {
    id: string,
    firstName: string,
    role: [ | \`Admin | \`User | \`FutureAddedValue(string)],
  };
  type response_setUserLocation = {
    changedUser: option(response_setUserLocation_changedUser),
  };
};

open Types;

type response = {setUserLocation: response_setUserLocation};
type variables = {input: setUserLocationInput};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"},\\"setUserLocation_changedUser_role\\":{\\"e\\":\\"enum_UserRole\\"}}} |}
  ];
  let wrapResponseConverterMap = {\\"enum_UserRole\\": wrap_enum_UserRole};
  let convertWrapResponse = v =>
    v
    ->ReasonRelay._convertObj(
        wrapResponseConverter,
        wrapResponseConverterMap,
        Js.null,
      );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"},\\"setUserLocation_changedUser_role\\":{\\"e\\":\\"enum_UserRole\\"}}} |}
  ];
  let responseConverterMap = {\\"enum_UserRole\\": unwrap_enum_UserRole};
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"SetUserLocationInput\\":{\\"clientMutationId\\":{\\"n\\":\\"\\"},\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}}} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {
  let make_locationBounds = (~lat, ~lng, ~child=?, ()): locationBounds => {
    lat,
    lng,
    child,
  };

  let make_setUserLocationInput =
      (~clientMutationId=?, ~userId, ~location=?, ()): setUserLocationInput => {
    clientMutationId,
    userId,
    location,
  };

  let makeVariables = (~input): variables => {input: input};

  let make_response_setUserLocation_changedUser =
      (~id, ~firstName, ~role): response_setUserLocation_changedUser => {
    id,
    firstName,
    role,
  };

  let make_response_setUserLocation =
      (~changedUser=?, ()): response_setUserLocation => {
    changedUser: changedUser,
  };

  let makeOptimisticResponse = (~setUserLocation): response => {
    setUserLocation: setUserLocation,
  };
};

type operationType = ReasonRelay.mutationNode;
"
`;

exports[`Language plugin tests Mutation prints the correct basic structure for mutations 1`] = `
"// SetUserLocationMutation.graphql
/* @generated */

module Unions = {};

module Types = {
  type locationBounds = {
    lat: float,
    lng: float,
    child: option(locationBounds),
  };
  type setUserLocationInput = {
    clientMutationId: option(string),
    userId: string,
    location: option(locationBounds),
  };
  type response_setUserLocation_changedUser = {
    id: string,
    firstName: string,
  };
  type response_setUserLocation = {
    changedUser: option(response_setUserLocation_changedUser),
  };
};

open Types;

type response = {setUserLocation: response_setUserLocation};
type variables = {input: setUserLocationInput};

module Internal = {
  type wrapResponseRaw;
  let wrapResponseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}} |}
  ];
  let wrapResponseConverterMap = ();
  let convertWrapResponse = v =>
    v
    ->ReasonRelay._convertObj(
        wrapResponseConverter,
        wrapResponseConverterMap,
        Js.null,
      );

  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"setUserLocation_changedUser\\":{\\"n\\":\\"\\"}}} |}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"input\\":{\\"r\\":\\"SetUserLocationInput\\"}},\\"LocationBounds\\":{\\"child\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}},\\"SetUserLocationInput\\":{\\"clientMutationId\\":{\\"n\\":\\"\\"},\\"location\\":{\\"n\\":\\"\\",\\"r\\":\\"LocationBounds\\"}}} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {
  let make_locationBounds = (~lat, ~lng, ~child=?, ()): locationBounds => {
    lat,
    lng,
    child,
  };

  let make_setUserLocationInput =
      (~clientMutationId=?, ~userId, ~location=?, ()): setUserLocationInput => {
    clientMutationId,
    userId,
    location,
  };

  let makeVariables = (~input): variables => {input: input};

  let make_response_setUserLocation_changedUser =
      (~id, ~firstName): response_setUserLocation_changedUser => {
    id,
    firstName,
  };

  let make_response_setUserLocation =
      (~changedUser=?, ()): response_setUserLocation => {
    changedUser: changedUser,
  };

  let makeOptimisticResponse = (~setUserLocation): response => {
    setUserLocation: setUserLocation,
  };
};

type operationType = ReasonRelay.mutationNode;
"
`;

exports[`Language plugin tests Query connections generates helpers for connections with unions 1`] = `
"// TestPagination_query.graphql
/* @generated */

module Unions = {
  module Union_fragment_participantsConnection_edges_node: {
    type wrapped;
    type fragment_participantsConnection_edges_node_user = {
      firstName: string,
      id: string,
    };
    type user = fragment_participantsConnection_edges_node_user;
    type fragment_participantsConnection_edges_node_observer = {
      name: string,
      id: string,
    };
    type observer = fragment_participantsConnection_edges_node_observer;
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    let unwrap: wrapped => t;
  } = {
    type wrapped;
    type fragment_participantsConnection_edges_node_user = {
      firstName: string,
      id: string,
    };
    type user = fragment_participantsConnection_edges_node_user;
    type fragment_participantsConnection_edges_node_observer = {
      name: string,
      id: string,
    };
    type observer = fragment_participantsConnection_edges_node_observer;
    external __unwrap_union: wrapped => {. \\"__typename\\": string} =
      \\"%identity\\";
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    external __unwrap_user: wrapped => user = \\"%identity\\";
    external __unwrap_observer: wrapped => observer = \\"%identity\\";
    external __toJson: wrapped => Js.Json.t = \\"%identity\\";
    let unwrap = wrapped => {
      let unwrappedUnion = wrapped |> __unwrap_union;
      switch (unwrappedUnion##__typename) {
      | \\"User\\" => \`User(wrapped |> __unwrap_user)
      | \\"Observer\\" => \`Observer(wrapped |> __unwrap_observer)
      | typename => \`UnselectedUnionMember(typename)
      };
    };
  };

  type union_fragment_participantsConnection_edges_node = [
    | \`User(Union_fragment_participantsConnection_edges_node.user)
    | \`Observer(Union_fragment_participantsConnection_edges_node.observer)
    | \`UnselectedUnionMember(string)
  ];
};

open Unions;

module Types = {
  type fragment_participantsConnection_edges = {
    node: option(union_fragment_participantsConnection_edges_node),
  };
  type fragment_participantsConnection = {
    edges: option(array(option(fragment_participantsConnection_edges))),
  };
};

open Types;

type fragment = {
  participantsConnection: option(fragment_participantsConnection),
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"participantsConnection\\":{\\"n\\":\\"\\"},\\"participantsConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"},\\"participantsConnection_edges_node\\":{\\"n\\":\\"\\",\\"u\\":\\"fragment_participantsConnection_edges_node\\"}}} |}
  ];
  let fragmentConverterMap = {
    \\"fragment_participantsConnection_edges_node\\": Union_fragment_participantsConnection_edges_node.unwrap,
  };
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__TestPagination_query\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {
  let getConnectionNodes_participantsConnection:
    option(fragment_participantsConnection) =>
    array(union_fragment_participantsConnection_edges_node) =
    connection =>
      switch (connection) {
      | None => [||]
      | Some(connection) =>
        switch (connection.edges) {
        | None => [||]
        | Some(edges) =>
          edges
          ->Belt.Array.keepMap(edge =>
              switch (edge) {
              | None => None
              | Some(edge) =>
                switch (edge.node) {
                | None => None
                | Some(node) => Some(node)
                }
              }
            )
        }
      };
};

type operationType = ReasonRelay.fragmentNode;
"
`;

exports[`Language plugin tests Query connections generates helpers for nested connection 1`] = `
"// TestPagination_query.graphql
/* @generated */

module Unions = {};

module Types = {
  type fragment_me_friendsConnection_edges_node = {
    id: string,
    firstName: string,
  };
  type fragment_me_friendsConnection_edges = {
    node: option(fragment_me_friendsConnection_edges_node),
  };
  type fragment_me_friendsConnection = {
    edges: option(array(option(fragment_me_friendsConnection_edges))),
  };
  type fragment_me = {
    friendsConnection: option(fragment_me_friendsConnection),
  };
};

open Types;

type fragment = {me: fragment_me};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"me_friendsConnection\\":{\\"n\\":\\"\\"},\\"me_friendsConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"},\\"me_friendsConnection_edges_node\\":{\\"n\\":\\"\\"}}} |}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__TestPagination_query\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {
  let getConnectionNodes_friendsConnection:
    option(fragment_me_friendsConnection) =>
    array(fragment_me_friendsConnection_edges_node) =
    connection =>
      switch (connection) {
      | None => [||]
      | Some(connection) =>
        switch (connection.edges) {
        | None => [||]
        | Some(edges) =>
          edges
          ->Belt.Array.keepMap(edge =>
              switch (edge) {
              | None => None
              | Some(edge) =>
                switch (edge.node) {
                | None => None
                | Some(node) => Some(node)
                }
              }
            )
        }
      };
};

type operationType = ReasonRelay.fragmentNode;
"
`;

exports[`Language plugin tests Query connections generates helpers for root level connection 1`] = `
"// TestPagination_query.graphql
/* @generated */

module Unions = {};

module Types = {
  type fragment_usersConnection_edges_node = {
    id: string,
    firstName: string,
  };
  type fragment_usersConnection_edges = {
    node: option(fragment_usersConnection_edges_node),
  };
  type fragment_usersConnection = {
    edges: option(array(option(fragment_usersConnection_edges))),
  };
};

open Types;

type fragment = {usersConnection: option(fragment_usersConnection)};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"usersConnection\\":{\\"n\\":\\"\\"},\\"usersConnection_edges\\":{\\"n\\":\\"\\",\\"na\\":\\"\\"},\\"usersConnection_edges_node\\":{\\"n\\":\\"\\"}}} |}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) =
  {.. \\"__$fragment_ref__TestPagination_query\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {
  let getConnectionNodes_usersConnection:
    option(fragment_usersConnection) =>
    array(fragment_usersConnection_edges_node) =
    connection =>
      switch (connection) {
      | None => [||]
      | Some(connection) =>
        switch (connection.edges) {
        | None => [||]
        | Some(edges) =>
          edges
          ->Belt.Array.keepMap(edge =>
              switch (edge) {
              | None => None
              | Some(edge) =>
                switch (edge.node) {
                | None => None
                | Some(node) => Some(node)
                }
              }
            )
        }
      };
};

type operationType = ReasonRelay.fragmentNode;
"
`;

exports[`Language plugin tests Query prints simple responses and variables 1`] = `
"// appQuery.graphql
/* @generated */

module Unions = {};

module Types = {
  type response_user = {
    id: string,
    firstName: string,
  };
};

open Types;

type response = {user: option(response_user)};
type refetchVariables = {userId: option(string)};
let makeRefetchVariables = (~userId=?, ()): refetchVariables => {
  userId: userId,
};
type variables = {userId: string};

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"user\\":{\\"n\\":\\"\\"}}} |}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {
  let makeVariables = (~userId): variables => {userId: userId};
};

type operationType = ReasonRelay.queryNode;
"
`;

exports[`Language plugin tests Subscription prints the correct basic structure for subscriptions 1`] = `
"// SomeSubscription.graphql
/* @generated */

module Unions = {};

module Types = {
  type userChangedInput = {
    clientMutationId: option(string),
    userId: string,
  };
  type response_userChanged_user = {
    id: string,
    firstName: string,
  };
  type response_userChanged = {user: option(response_userChanged_user)};
};

open Types;

type response = {userChanged: response_userChanged};
type variables = {input: userChangedInput};

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"userChanged_user\\":{\\"n\\":\\"\\"}}} |}
  ];
  let responseConverterMap = ();
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"input\\":{\\"r\\":\\"UserChangedInput\\"}},\\"UserChangedInput\\":{\\"clientMutationId\\":{\\"n\\":\\"\\"}}} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {
  let make_userChangedInput =
      (~clientMutationId=?, ~userId, ()): userChangedInput => {
    clientMutationId,
    userId,
  };

  let makeVariables = (~input): variables => {input: input};
};

type operationType = ReasonRelay.subscriptionNode;
"
`;

exports[`Language plugin tests Unions generates code to unwrap fragments on unions 1`] = `
"// app_user.graphql
/* @generated */

module Unions = {};

module Types = {};

type fragment = {
  id: string,
  firstName: string,
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) = {.. \\"__$fragment_ref__app_user\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {};

type operationType = ReasonRelay.fragmentNode;


// app_observer.graphql
/* @generated */

module Unions = {};

module Types = {};

type fragment = {
  id: string,
  name: string,
};

module Internal = {
  type fragmentRaw;
  let fragmentConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let fragmentConverterMap = ();
  let convertFragment = v =>
    v
    ->ReasonRelay._convertObj(
        fragmentConverter,
        fragmentConverterMap,
        Js.undefined,
      );
};

type t;
type fragmentRef;
type fragmentRefSelector('a) = {.. \\"__$fragment_ref__app_observer\\": t} as 'a;
external getFragmentRef: fragmentRefSelector('a) => fragmentRef = \\"%identity\\";

module Utils = {};

type operationType = ReasonRelay.fragmentNode;


// appQuery.graphql
/* @generated */

module Unions = {
  module Union_response_participantById: {
    type wrapped;
    type response_participantById_user = {
      id: string,
      getFragmentRefs:
        unit => {. \\"__$fragment_ref__app_user\\": App_user_graphql.t},
    };
    type user = response_participantById_user;
    type response_participantById_observer = {
      id: string,
      getFragmentRefs:
        unit => {. \\"__$fragment_ref__app_observer\\": App_observer_graphql.t},
    };
    type observer = response_participantById_observer;
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    let unwrap: wrapped => t;
  } = {
    type wrapped;
    type response_participantById_user = {
      id: string,
      getFragmentRefs:
        unit => {. \\"__$fragment_ref__app_user\\": App_user_graphql.t},
    };
    type user = response_participantById_user;
    type response_participantById_observer = {
      id: string,
      getFragmentRefs:
        unit => {. \\"__$fragment_ref__app_observer\\": App_observer_graphql.t},
    };
    type observer = response_participantById_observer;
    external __unwrap_union: wrapped => {. \\"__typename\\": string} =
      \\"%identity\\";
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    external __unwrap_user: wrapped => user = \\"%identity\\";
    external __unwrap_observer: wrapped => observer = \\"%identity\\";
    external __toJson: wrapped => Js.Json.t = \\"%identity\\";
    let unwrap = wrapped => {
      let unwrappedUnion = wrapped |> __unwrap_union;
      switch (unwrappedUnion##__typename) {
      | \\"User\\" => \`User(wrapped |> __unwrap_user)
      | \\"Observer\\" => \`Observer(wrapped |> __unwrap_observer)
      | typename => \`UnselectedUnionMember(typename)
      };
    };
  };

  type union_response_participantById = [
    | \`User(Union_response_participantById.user)
    | \`Observer(Union_response_participantById.observer)
    | \`UnselectedUnionMember(string)
  ];
};

open Unions;

module Types = {};

type response = {participantById: option(union_response_participantById)};
type variables = unit;

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_user\\":{\\"f\\":\\"\\"},\\"participantById_observer\\":{\\"f\\":\\"\\"}}} |}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": Union_response_participantById.unwrap,
  };
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {};

type operationType = ReasonRelay.queryNode;
"
`;

exports[`Language plugin tests Unions generates code to unwrap unions 1`] = `
"// appQuery.graphql
/* @generated */

module Unions = {
  module Union_response_participantById: {
    type wrapped;
    type response_participantById_user = {
      lastName: string,
      firstName: string,
      id: string,
    };
    type user = response_participantById_user;
    type response_participantById_observer = {
      name: string,
      id: string,
    };
    type observer = response_participantById_observer;
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    let unwrap: wrapped => t;
  } = {
    type wrapped;
    type response_participantById_user = {
      lastName: string,
      firstName: string,
      id: string,
    };
    type user = response_participantById_user;
    type response_participantById_observer = {
      name: string,
      id: string,
    };
    type observer = response_participantById_observer;
    external __unwrap_union: wrapped => {. \\"__typename\\": string} =
      \\"%identity\\";
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    external __unwrap_user: wrapped => user = \\"%identity\\";
    external __unwrap_observer: wrapped => observer = \\"%identity\\";
    external __toJson: wrapped => Js.Json.t = \\"%identity\\";
    let unwrap = wrapped => {
      let unwrappedUnion = wrapped |> __unwrap_union;
      switch (unwrappedUnion##__typename) {
      | \\"User\\" => \`User(wrapped |> __unwrap_user)
      | \\"Observer\\" => \`Observer(wrapped |> __unwrap_observer)
      | typename => \`UnselectedUnionMember(typename)
      };
    };
  };

  type union_response_participantById = [
    | \`User(Union_response_participantById.user)
    | \`Observer(Union_response_participantById.observer)
    | \`UnselectedUnionMember(string)
  ];
};

open Unions;

module Types = {};

type response = {participantById: option(union_response_participantById)};
type variables = unit;

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"}}} |}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": Union_response_participantById.unwrap,
  };
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {};

type operationType = ReasonRelay.queryNode;
"
`;

exports[`Language plugin tests Unions handles nested unions 1`] = `
"// appQuery.graphql
/* @generated */

type enum_ObserverStatus = [
  | \`Active
  | \`Inactive
  | \`FutureAddedValue(string)
];

let unwrap_enum_ObserverStatus: string => enum_ObserverStatus =
  fun
  | \\"Active\\" => \`Active
  | \\"Inactive\\" => \`Inactive
  | v => \`FutureAddedValue(v);

let wrap_enum_ObserverStatus: enum_ObserverStatus => string =
  fun
  | \`Active => \\"Active\\"
  | \`Inactive => \\"Inactive\\"
  | \`FutureAddedValue(v) => v;

module Unions = {
  module Union_response_participantById_observer_manager: {
    type wrapped;
    type response_participantById_observer_manager_user = {
      lastName: string,
      firstName: string,
      id: string,
    };
    type user = response_participantById_observer_manager_user;
    type response_participantById_observer_manager_observer = {
      status: [ | \`Active | \`Inactive | \`FutureAddedValue(string)],
      isOnline: option(bool),
      id: string,
    };
    type observer = response_participantById_observer_manager_observer;
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    let unwrap: wrapped => t;
  } = {
    type wrapped;
    type response_participantById_observer_manager_user = {
      lastName: string,
      firstName: string,
      id: string,
    };
    type user = response_participantById_observer_manager_user;
    type response_participantById_observer_manager_observer = {
      status: [ | \`Active | \`Inactive | \`FutureAddedValue(string)],
      isOnline: option(bool),
      id: string,
    };
    type observer = response_participantById_observer_manager_observer;
    external __unwrap_union: wrapped => {. \\"__typename\\": string} =
      \\"%identity\\";
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    external __unwrap_user: wrapped => user = \\"%identity\\";
    external __unwrap_observer: wrapped => observer = \\"%identity\\";
    external __toJson: wrapped => Js.Json.t = \\"%identity\\";
    let unwrap = wrapped => {
      let unwrappedUnion = wrapped |> __unwrap_union;
      switch (unwrappedUnion##__typename) {
      | \\"User\\" => \`User(wrapped |> __unwrap_user)
      | \\"Observer\\" => \`Observer(wrapped |> __unwrap_observer)
      | typename => \`UnselectedUnionMember(typename)
      };
    };
  };

  type union_response_participantById_observer_manager = [
    | \`User(Union_response_participantById_observer_manager.user)
    | \`Observer(Union_response_participantById_observer_manager.observer)
    | \`UnselectedUnionMember(string)
  ];

  module Union_response_participantById: {
    type wrapped;
    type response_participantById_user = {
      lastName: string,
      firstName: string,
      id: string,
    };
    type user = response_participantById_user;
    type response_participantById_observer = {
      manager: option(union_response_participantById_observer_manager),
      name: string,
      id: string,
    };
    type observer = response_participantById_observer;
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    let unwrap: wrapped => t;
  } = {
    type wrapped;
    type response_participantById_user = {
      lastName: string,
      firstName: string,
      id: string,
    };
    type user = response_participantById_user;
    type response_participantById_observer = {
      manager: option(union_response_participantById_observer_manager),
      name: string,
      id: string,
    };
    type observer = response_participantById_observer;
    external __unwrap_union: wrapped => {. \\"__typename\\": string} =
      \\"%identity\\";
    type t = [
      | \`User(user)
      | \`Observer(observer)
      | \`UnselectedUnionMember(string)
    ];
    external __unwrap_user: wrapped => user = \\"%identity\\";
    external __unwrap_observer: wrapped => observer = \\"%identity\\";
    external __toJson: wrapped => Js.Json.t = \\"%identity\\";
    let unwrap = wrapped => {
      let unwrappedUnion = wrapped |> __unwrap_union;
      switch (unwrappedUnion##__typename) {
      | \\"User\\" => \`User(wrapped |> __unwrap_user)
      | \\"Observer\\" => \`Observer(wrapped |> __unwrap_observer)
      | typename => \`UnselectedUnionMember(typename)
      };
    };
  };

  type union_response_participantById = [
    | \`User(Union_response_participantById.user)
    | \`Observer(Union_response_participantById.observer)
    | \`UnselectedUnionMember(string)
  ];
};

open Unions;

module Types = {};

type response = {participantById: option(union_response_participantById)};
type variables = unit;

module Internal = {
  type responseRaw;
  let responseConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {\\"__root\\":{\\"participantById\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById\\"},\\"participantById_observer_manager\\":{\\"n\\":\\"\\",\\"u\\":\\"response_participantById_observer_manager\\"},\\"participantById_observer_manager_observer_status\\":{\\"e\\":\\"enum_ObserverStatus\\"},\\"participantById_observer_manager_observer_isOnline\\":{\\"n\\":\\"\\"}}} |}
  ];
  let responseConverterMap = {
    \\"response_participantById\\": Union_response_participantById.unwrap,
    \\"response_participantById_observer_manager\\": Union_response_participantById_observer_manager.unwrap,
    \\"enum_ObserverStatus\\": unwrap_enum_ObserverStatus,
  };
  let convertResponse = v =>
    v
    ->ReasonRelay._convertObj(
        responseConverter,
        responseConverterMap,
        Js.undefined,
      );

  let variablesConverter: Js.Dict.t(Js.Dict.t(Js.Dict.t(string))) = [%raw
    {| {} |}
  ];
  let variablesConverterMap = ();
  let convertVariables = v =>
    v
    ->ReasonRelay._convertObj(
        variablesConverter,
        variablesConverterMap,
        Js.undefined,
      );
};

module Utils = {};

type operationType = ReasonRelay.queryNode;
"
`;
