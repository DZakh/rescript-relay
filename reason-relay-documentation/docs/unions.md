---
id: unions
title: Unions
sidebar_label: Unions
---

#### Recommended background reading

- [Union Types in GraphQL](https://graphql.org/learn/schema/#union-types)

## Unions in ReasonRelay

Since ReasonML's type system is quite different to Flow/TypeScript, working with unions is different in ReasonRelay compared to regular Relay. In ReasonRelay, each union will need to be _unwrapped_. Don't worry, it's very easy and everything you need is autogenerated for you, you just need to remember to do the actual unwrapping.

Let's clarify this with an example. Imagine this GraphQL schema:

```graphql
type User {
  id: ID!
  firstName: String!
  lastName: String!
}

type Group {
  id: ID!
  name: String!
}

union Owner = User | Group

type Query {
  roomOwner(roomId: ID!): Owner
}
```

Here we have a union `Owner` that's either a `User` or a `Group`. There's also a root field called `roomOwner` which returns the `Owner` of a room. Let's look at how using that union looks in ReasonRelay:

```reason
/* RoomOwner.re */
module Query = [%relay.query {|
  query RoomOwnerQuery($roomId: ID!) {
    roomOwner(roomId: $roomId) {
      __typename

      ... on User {
        firstName
        lastName
      }

      ... on Group {
        fullName
      }
    }
  }
|}]

[@react.component]
let make = (~roomId) => {
  let queryData = Query.use(~variables={"roomId": roomId}, ());

  switch (queryData##roomOwner |> Js.Nullable.toOption) {
  | Some(roomOwner) =>
    <div>
      {React.string("Room is owned by ")}
      {switch (roomOwner |> Query.Union_response_roomOwner.unwrap) {
       | `User(user) =>
         React.string("user " ++ user##firstName ++ " " ++ user##lastName)
       | `Group(group) => React.string("group " ++ group##name)
       | `UnmappedUnionMember => React.string("-")
       }}
    </div>
  };
};
```

Let's break down what's going on here:

1. We make our union selection in the GraphQL query. Note that we select `__typename` even though we don't use it anywhere - ReasonRelay enforces this, you must select `__typename` for all unions. Don't worry, the compiler will scream at you if you forget it.
2. We fetch our query data, and we switch on `roomOwner` to make sure it's actually there in the data.
3. When we have `roomOwner`, we use the function `Query.Union_response_roomOwner.unwrap` on it. Now what on earth is that? Well, any time you have a union in _any_ of your GraphQL operations, the module you assign your GraphQL operation to will include a module called `Union_path_to_where_the_union_is_located`. This module will contain type information and a way to _unwrap_ your union, just like we're doing here.
4. Unwrapping returns a polymorphic variant representing each possible type of the union, and the fields selected on that type. It also adds `UnmappedUnionMember` to every union, which will force you to handle _what happens if there's another member added to the union before you have time to update your app_. This is pretty neat way to ensure you gracefully handle your schema evolving.

## Wrapping up (pun intended)

And that's that! Keep the following in mind about unions and everything will be fine:

- Remember to select `__typename`
- Remember to unwrap your union
- Remember to handle `UnmappedUnionMember`
